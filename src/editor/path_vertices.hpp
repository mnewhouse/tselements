/*
* TS Elements
* Copyright 2015-2016 M. Newhouse
* Released under the MIT license.
*/

#ifndef PATH_VERTICES_HPP_384912834
#define PATH_VERTICES_HPP_384912834

#include "track_path.hpp"
#include "model_3d.hpp"

#include <limits>
#include <vector>
#include <cstdint>

namespace ts
{
  namespace scene_3d
  {
    using PathNodeIterator = std::vector<resources_3d::TrackPathNode>::const_iterator;

    struct PathVertexPoint
    {
      PathNodeIterator first;
      PathNodeIterator second;
      float time_point = 0.0f;
      Vector2f point;
      Vector2f normal;
    };

    struct PathVertex
    {
      Vector2f position;
      Vector3f tex_coords;
      Vector3f normal;
      Colorb color;
    };

    struct PathCellAlignment
    {
      bool align = true;
      std::int32_t cell_size;

      enum TriangleOrientation
      {
        TopLeft,
        BottomLeft
      } triangle_orientation;
    };

    namespace detail
    {
      struct EdgeIntersection
      {
        enum Type : std::int16_t
        {
          Horizontal, Vertical, Diagonal, CellCorner, QuadCorner
        };

        Vector2f intersection;
        Vector2i cell;
        Type type;
        std::int16_t cell_offset;
        std::uint32_t edge_index;
        std::uint32_t vertex_index = std::numeric_limits<std::uint32_t>::max();

        enum CornerIndex : std::uint32_t
        {
          TopLeft = 0x10001, BottomLeft, TopRight, BottomRight
        };
      };
    }

    // Precompute the points at which path vertices will be generated.
    // This is useful when a path has more than one stroke type, 
    // Lower tolerance values will give smoother results at the cost of more vertices.
    // 0.0 < tolerance <= 1.0, but it should not be too close to zero. (i.e. not below +- 0.01)
    void compute_path_vertex_points(PathNodeIterator node_it,
                                    PathNodeIterator node_end,
                                    float tolerance,
                                    std::vector<PathVertexPoint>& vertex_points);

    // Generate the model according to the vertex points previously generated by
    // compute_path_vertex_points.
    // * Requirements
    // * VertexFunc must be a function that takes a single PathVertex parameter and
    //   returns something that's convertible to VertexType.
    template <typename VertexType, typename VertexFunc>
    void generate_path_vertices(const resources_3d::TrackPath& path,
                                const resources_3d::SegmentedStroke& stroke,
                                const std::vector<PathVertexPoint>& points,
                                float texture_size, float texture_z,
                                resources_3d::BasicModel<VertexType>& output_model,
                                VertexFunc&& vertex_func);

    template <typename VertexType, typename VertexFunc>
    void generate_path_vertices(const resources_3d::TrackPath& path,
                                const resources_3d::StrokeProperties& stroke_properties,
                                const std::vector<PathVertexPoint>& points,
                                float texture_size, float texture_z,
                                resources_3d::BasicModel<VertexType>& output_model,
                                VertexFunc&& vertex_func);
  }
}

#endif