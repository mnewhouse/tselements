/*
* TS Elements
* Copyright 2015-2016 M. Newhouse
* Released under the MIT license.
*/

#ifndef PATH_VERTICES_DETAIL_HPP_843192834
#define PATH_VERTICES_DETAIL_HPP_843192834

#include "path_vertices.hpp"

#include <algorithm>
#include <cstdint>

namespace ts
{
  namespace scene_3d
  {
    namespace detail
    {
      template <typename NodeIt>
      auto make_path_vertex_point_at(NodeIt first_node, NodeIt second_node, float time_point)
      {
        PathVertexPoint<NodeIt> point;
        point.first = first_node;
        point.second = second_node;
        point.time_point = time_point;
        point.normal = resources_3d::path_normal_at(*first_node, *second_node, time_point);
        point.point = resources_3d::path_point_at(*first_node, *second_node, time_point);
        return point;
      }

      template <typename NodeIt>
      void divide_path_segment(std::vector<PathVertexPoint<NodeIt>>& vertex_points,
                               NodeIt first_node, NodeIt second_node,
                               Vector2f start_normal, Vector2f end_normal,
                               float min_time_point, float max_time_point, float tolerance)
      {
        if (std::abs(cross_product(start_normal, end_normal)) > tolerance)
        {
          auto time_interval = max_time_point - min_time_point;
          auto time_point = min_time_point + time_interval * 0.5f;
          auto normal = resources_3d::path_normal_at(*first_node, *second_node, time_point);

          divide_path_segment(vertex_points, first_node, second_node,
                              start_normal, normal,
                              min_time_point, time_point,
                              tolerance);

          vertex_points.push_back(make_path_vertex_point_at(first_node, second_node, time_point));

          divide_path_segment(vertex_points, first_node, second_node,
                              normal, end_normal,
                              time_point, max_time_point,
                              tolerance);
        }
      }
    }

    // Precompute the points at which path vertices will be generated.
    // This is useful when a path has more than one stroke type, 
    // Lower tolerance values will give smoother results at the cost of more vertices.
    // 0.0 < tolerance <= 1.0, but it should not be too close to zero.
    // PathNodeIt must be a forward iterator that dereferences to resources_3d::TrackPathNode.
    template <typename PathNodeIt>
    auto compute_path_vertex_points(PathNodeIt node_it, PathNodeIt node_end, float tolerance,
                                    std::vector<PathVertexPoint<PathNodeIt>>& result)
    {
      using info_type = PathVertexPoint<PathNodeIt>;

      if (node_it != node_end)
      {
        auto next_node_it = std::next(node_it);
        for (; next_node_it != node_end; ++next_node_it, ++node_it)
        {
          // Divide the segment into 3 sub-segments to start with.
          // We could do just one sub-segment, but that way it won't work correctly for
          // some more complex paths.
          auto points =
          {
            detail::make_path_vertex_point_at(node_it, next_node_it, 0.0f),
            detail::make_path_vertex_point_at(node_it, next_node_it, 1.0f / 3),
            detail::make_path_vertex_point_at(node_it, next_node_it, 2.0f / 3),
            detail::make_path_vertex_point_at(node_it, next_node_it, 1.0f)
          };

          auto point_it = std::begin(points);
          auto next_point_it = std::next(point_it);
          for (; next_point_it != std::end(points); ++point_it, ++next_point_it)
          {
            result.push_back(*point_it);

            // Recursively divide the segment until it's smooth enough.
            detail::divide_path_segment(result, node_it, next_node_it,
                                        point_it->normal, next_point_it->normal,
                                        point_it->time_point, next_point_it->time_point,
                                        tolerance);
          }

          


          result.push_back(*point_it);       
        }
      }

      return result;
    }

    // Generate the vertices according to the vertex points previously generated by
    // compute_path_vertex_points. It writes the vertices and indices to the given
    // output iterators. 
    // The following syntax must be supported: *vertex_out++ = vertex_func(Vector2f(position))
    // It also performs the operation *index_out++ = std::size_t(start_index + index)
    template <typename PathNodeIt, typename VertexFunc, typename VertexOut, typename IndexOut>
    auto generate_path_vertices(const std::vector<PathVertexPoint<PathNodeIt>>& points,
                                const resources_3d::TrackPathStroke& stroke_properties,
                                VertexFunc&& vertex_func, VertexOut vertex_out,
                                std::uint32_t start_index, IndexOut index_out)
    {
      using resources_3d::TrackPathNode;
      auto point_it = points.begin();
      if (point_it != points.end())
      {
        auto next_point_it = std::next(point_it);
        for (; next_point_it != points.end(); ++next_point_it, ++point_it)
        {
          using Point = PathVertexPoint<PathNodeIt>;

          const Point& point = *point_it;
          const Point& next_point = *next_point_it;

          using resources_3d::TrackPathNode;
          const TrackPathNode& first_node = *point.first;
          const TrackPathNode& second_node = *point.second;

          auto width = second_node.width * point.time_point +
            first_node.width * (1.0f - point.time_point);

          auto next_width = next_point.second->width * next_point.time_point +
            next_point.first->width * (1.0f - next_point.time_point);

          width *= 0.5f;
          next_width *= 0.5f;

          auto stroke_width = stroke_properties.width;
          auto next_stroke_width = stroke_width;
          auto stroke_offset = stroke_properties.offset;
          auto next_stroke_offset = stroke_offset;
          
          if (stroke_properties.use_relative_size)
          {
            stroke_width *= width;
            next_stroke_width *= next_width;
            stroke_offset *= width;
            next_stroke_offset *= next_width;
          }

          auto index_func = [=](std::uint32_t index) { return index + start_index; };

          if (stroke_properties.type == resources_3d::TrackPathStroke::Border)
          {
            auto outer = point.normal * (width - stroke_offset);
            auto next_outer = next_point.normal * (next_width - next_stroke_offset);
            auto inner = point.normal * (width - stroke_offset - stroke_width);
            auto next_inner = next_point.normal * (next_width - next_stroke_offset - next_stroke_width);

            Vector2f positions[] =
            {
              point.point + outer,
              next_point.point + next_outer,
              point.point + inner,
              next_point.point + next_inner,

              // Other side
              point.point - outer,
              next_point.point - next_outer,
              point.point - inner,
              next_point.point - next_inner
            };

            const std::uint32_t indices[] =
            {
              0, 1, 2, 1, 2, 3, 4, 5, 6, 5, 6, 7
            };

            vertex_out = std::transform(std::begin(positions), std::end(positions),
                                        vertex_out, vertex_func);

            index_out = std::transform(std::begin(indices), std::end(indices),
                                       index_out, index_func);

            start_index += 8;
          }

          else
          {

            Vector2f positions[] =
            {
              point.point + point.normal * stroke_width,
              next_point.point + next_point.normal * next_stroke_width,
              point.point - point.normal * stroke_width,
              next_point.point - next_point.normal * next_stroke_width
            };

            const std::uint32_t indices[] =
            {
              0, 1, 2, 1, 2, 3
            };

            vertex_out = std::transform(std::begin(positions), std::end(positions),
                                        vertex_out, vertex_func);

            index_out = std::transform(std::begin(indices), std::end(indices),
                                       index_out, index_func);

            start_index += 4;
          }
        }
      }

      return std::make_pair(vertex_out, index_out);
    }
  }
}

#endif